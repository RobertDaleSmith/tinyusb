[1mdiff --git a/src/portable/ohci/ohci.c b/src/portable/ohci/ohci.c[m
[1mindex af7b8fe2..5d6db689 100644[m
[1m--- a/src/portable/ohci/ohci.c[m
[1m+++ b/src/portable/ohci/ohci.c[m
[36m@@ -208,7 +208,7 @@[m [mbool hcd_init(uint8_t rhport)[m
       OHCI_INT_UNRECOVERABLE_ERROR_MASK | OHCI_INT_FRAME_OVERFLOW_MASK | OHCI_INT_RHPORT_STATUS_CHANGE_MASK |[m
       OHCI_INT_MASTER_ENABLE_MASK;[m
 [m
[31m-  OHCI_REG->control |= OHCI_CONTROL_CONTROL_BULK_RATIO | OHCI_CONTROL_LIST_CONTROL_ENABLE_MASK |[m
[32m+[m[32m  OHCI_REG->control = OHCI_CONTROL_CONTROL_BULK_RATIO | OHCI_CONTROL_LIST_CONTROL_ENABLE_MASK |[m
        OHCI_CONTROL_LIST_BULK_ENABLE_MASK | OHCI_CONTROL_LIST_PERIODIC_ENABLE_MASK; // TODO Isochronous[m
 [m
   OHCI_REG->frame_interval = (OHCI_FMINTERVAL_FSMPS << 16) | OHCI_FMINTERVAL_FI;[m
[36m@@ -219,15 +219,6 @@[m [mbool hcd_init(uint8_t rhport)[m
   OHCI_REG->rh_status_bit.local_power_status_change = 1; // set global power for ports[m
   osal_task_delay(OHCI_REG->rh_descriptorA_bit.power_on_to_good_time * 2); // Wait POTG after power up[m
 [m
[31m-  //OCHI may not generate RH interrupts on pre-existing devices. Force a device reset[m
[31m-  for (int i = 0; i < OHCI_RHPORTS; i++)[m
[31m-  {[m
[31m-    if (OHCI_REG->rhport_status_bit[i].current_connect_status == 1)[m
[31m-    {[m
[31m-      OHCI_REG->rhport_status[i] = RHPORT_PORT_RESET_STATUS_MASK;[m
[31m-    }[m
[31m-  }[m
[31m-[m
   return true;[m
 }[m
 [m
